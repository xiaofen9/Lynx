// Generated by CoffeeScript 1.12.3

/*
This program is distributed under the terms of the MIT license.
Copyright 2012 - 2016 (c) Markus Kohlhase <mail@markus-kohlhase.de>
 */

(function() {
  var async, collect, colorRegex, exts, filterFiles, fmtOpts, fmts, fs, groupByExt, helpers, k, keyvalue, list, object, options, parseFile, path, pkg, print, programm, readDir, readSingleFile, readSource, readdirp, sloc;

  fs = require('fs');

  path = require('path');

  async = require('async');

  programm = require('commander');

  readdirp = require('readdirp');

  sloc = require('./sloc');

  helpers = require('./helpers');

  pkg = require('../package.json');

  fmts = require('./formatters');

  list = function(val) {
    return val.split(',');
  };

  keyvalue = function(val) {
    return val.split('=');
  };

  object = function(val) {
    var custom, i, len, original, ref, result, split;
    result = {};
    ref = list(val).map(keyvalue);
    for (i = 0, len = ref.length; i < len; i++) {
      split = ref[i];
      custom = split[0], original = split[1];
      result[custom] = original;
    }
    return result;
  };

  exts = (function() {
    var i, len, ref, results;
    ref = sloc.extensions;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      k = ref[i];
      results.push("*." + k);
    }
    return results;
  })();

  collect = function(val, memo) {
    memo.push(val);
    return memo;
  };

  colorRegex = /\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]/g;

  parseFile = function(f, cb) {
    var res;
    if (cb == null) {
      cb = function() {};
    }
    res = {
      path: f,
      stats: {},
      badFile: false
    };
    return fs.readFile(f, "utf8", function(err, code) {
      var ext;
      if (err) {
        res.badFile = true;
        return cb(err, res);
      }
      ext = path.extname(f).slice(1);
      res.stats = sloc(code, options.alias[ext] || ext);
      return cb(null, res);
    });
  };

  print = function(result, opts, fmtOpts) {
    var f, fmt, out;
    f = programm.format || 'simple';
    if ((fmt = fmts[f]) == null) {
      return console.error("Error: format " + f + " is not supported");
    }
    out = fmt(result, opts, fmtOpts);
    if (programm.stripColors) {
      out = out.replace(colorRegex, '');
    }
    if (typeof out === "string") {
      return console.log(out);
    }
  };

  filterFiles = function(files) {
    var exclude, i, len, r, res, results;
    res = programm.exclude ? (exclude = new RegExp(programm.exclude), files.filter(function(x) {
      return !exclude.test(x.path);
    })) : files;
    results = [];
    for (i = 0, len = res.length; i < len; i++) {
      r = res[i];
      results.push(r.path);
    }
    return results;
  };

  options = {};

  fmtOpts = [];

  programm.version(pkg.version).usage('[option] <file> | <directory>').option('-e, --exclude <regex>', 'regular expression to exclude files and folders').option('-f, --format <format>', 'format output:' + ((function() {
    var results;
    results = [];
    for (k in fmts) {
      results.push(" " + k);
    }
    return results;
  })()).join(',')).option('--format-option [value]', 'add formatter option', collect, fmtOpts).option('--strip-colors', 'remove all color characters').option('-k, --keys <keys>', 'report only numbers of the given keys', list).option('-d, --details', 'report stats of each analyzed file').option('-a, --alias <custom ext>=<standard ext>', 'alias custom ext to act like standard ext', object);

  programm.parse(process.argv);

  options.keys = programm.keys;

  options.details = programm.details;

  options.alias = programm.alias;

  for (k in options.alias) {
    exts.push("*." + k);
  }

  if (programm.args.length < 1) {
    return programm.help();
  }

  groupByExt = function(data) {
    var d, ext, f, i, len, m, map, ref;
    map = {};
    ref = data.files;
    for (i = 0, len = ref.length; i < len; i++) {
      f = ref[i];
      ext = (path.extname(f.path)).slice(1);
      m = map[ext] != null ? map[ext] : map[ext] = {
        files: []
      };
      m.files.push(f);
    }
    for (ext in map) {
      d = map[ext];
      d.summary = helpers.summarize(d.files.map(function(x) {
        return x.stats;
      }));
    }
    return map;
  };

  readSingleFile = function(f, done) {
    return parseFile(f, function(err, res) {
      return done(err, [res]);
    });
  };

  readDir = function(dir, done) {
    var processFile;
    processFile = function(f, next) {
      return parseFile(path.join(dir, f), next);
    };
    return readdirp({
      root: dir,
      fileFilter: exts
    }, function(err, res) {
      if (err) {
        return done(err);
      }
      return async.mapLimit(filterFiles(res.files), 1000, processFile, done);
    });
  };

  readSource = function(p, done) {
    return fs.lstat(p, function(err, stats) {
      if (err) {
        console.error("Error: invalid path argument " + p);
        return done(err);
      }
      if (stats.isDirectory()) {
        return readDir(p, done);
      } else if (stats.isFile()) {
        return readSingleFile(p, done);
      }
    });
  };

  async.map(programm.args, readSource, function(err, parsed) {
    var result;
    if (err) {
      return console.error("Error: " + err);
    }
    result = {
      files: []
    };
    parsed.forEach(function(files) {
      return files.forEach(function(f) {
        if (f.badFile) {
          result.brokenFiles++;
        }
        return result.files.push(f);
      });
    });
    result.summary = helpers.summarize(result.files.map(function(x) {
      return x.stats;
    }));
    result.byExt = groupByExt(result);
    return print(result, options, fmtOpts);
  });

}).call(this);
